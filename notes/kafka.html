<!DOCTYPE html>

<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">

    <link href="../styles/maia.experimental.css" rel="stylesheet">

    <link href="../styles/portfolio.css" rel="stylesheet">

    <link href="../styles/bootstrap.css" rel="stylesheet">

    <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.4/jquery.min.js"></script> <!-- JQuery-->




    <link href="https://fonts.googleapis.com/css?family=Roboto:100,300,400,500,700,900&amp;subset=latin-ext" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Raleway:100,300,400,600&amp;subset=latin-ext" rel="stylesheet">
        <link href="http://fonts.googleapis.com/css?family=Roboto+Slab:300,400" rel="stylesheet" type="text/css">

        <script src="../scripts/handlebars-v4.0.5.js"></script>	<!-- handlebar library -->
    <script src="../scripts/bootstrap.min.js"></script> <!-- bootsrap libraries -->
    <script src="../scripts/jquery.lettering.js"></script>	<!-- lettering library -->
    <script src="../scripts/jquery.textillate.js"></script>	<!-- textillate library -->


    <title>Kafka</title>
</head>

<body>

	               <!-- progress indicator-->
                   <div class="progress-indicator" aria-valuemin="0" aria-valuemax="100" role="progressbar">
						<div class="progress-indicator__wrapper">
						  <div class="progress-indicator__bar1"></div>
						  <div class="progress-indicator__bar2"></div>
						</div>
				</div>
	
				<!-- Header-->
				<header role="banner" class="page-header has-submenu">
					<nav class="page-header__drawer sticky-header">
						<div class="page-header__content content-controls content-controls--flex">
	
							<!-- for the home logo-->
							<div class="page-nav__header">
								<div class="page-logo-lockup gc-header-dt__lockup">
									<div title="Google Careers" aria-label="Google Careers" class="page-logo gc-header-dt__logo" data-ga-action="Header nav_Select" data-ga-label="Google Careers logo" role="menuitem">
										<div class="page-logo-text gc-header-dt__product-logo">
											<span aria-hidden="true" class="page-logo-text-span gc-header-dt__product-logo-text">Study space</span>
										</div>
									</div>
								</div>
	
							</div>
	
							<!--Container for the nav bars-->
							<div class="gc-header-dt__nav">
								<ul class="gc-header-dt__nav-list">

									<li class="gc-header-dt__nav-list-item">
											<a href="../index.html"  aria-label="Selected Link: Teams" data-ga-action="Header nav_Select" data-ga-label="Teams" role="menuitem">
												Home
											</a>
									</li>
									<li class="gc-header-dt__nav-list-item">
										<a href="../notes.html" class="active" aria-label="Selected Link: Teams" data-ga-action="Header nav_Select" data-ga-label="Teams" role="menuitem">
											Notes
										</a>
									</li>
									<li class="gc-header-dt__nav-list-item">
										<a href="../resources.html" aria-label="Selected Link: Teams" data-ga-action="Header nav_Select" data-ga-label="Teams" role="menuitem">
											Resources
										</a>
									</li>

									<li class="gc-header-dt__nav-list-item">
											<a href="#"  aria-label="Selected Link: Teams" data-ga-action="Header nav_Select" data-ga-label="Teams" role="menuitem">
												Resume
											</a>
									</li>
								</ul>
	
							</div>
						
						</div>
	
                    </nav>
                    
                    <nav class="page-header__drawer sticky-header" >
                            <div class="page-header__content content-controls content-controls--flex" style="background-color: rgb(240,240,240);">
        
                                <!-- for the home logo-->
                                <div class="page-nav__header">
                                    <div class="page-logo-lockup gc-header-dt__lockup">
                                        <a href="#" title="Google Careers" aria-label="Google Careers" class="page-logo gc-header-dt__logo" data-ga-action="Header nav_Select" data-ga-label="Google Careers logo" role="menuitem">
                                            <div class="page-logo-text gc-header-dt__product-logo">
                                                <span aria-hidden="true" class="page-logo-text-span gc-header-dt__product-logo-text"></span>
                                            </div>
                                        </a>
                                    </div>
        
                                </div>
        
                                <!--Container for the nav bars-->
                                <div class="gc-header-dt__nav" style="margin-left: 11.8rem;">
                                    <ul class="gc-header-dt__nav-list">

                                        <li class="gc-header-dt__nav-list-item">
                                                    <a href="#" class="active"  aria-label="Selected Link: Teams" role="menuitem" >
                                                            Kafka
                                                    </a>
                                        </li>
                             
                                        <li class="gc-header-dt__nav-list-item">
                                                <a href="graph_ql.html"  aria-label="Selected Link: Teams" role="menuitem" >
                                                        GraphQL
                                                </a>
                                        </li>

                                    </ul>
        
                                </div>
                            
                            </div>
        
                        </nav>
	
	
                </header>

<div class="page-body" data-modal-source id="a11y-main" role="main" tabindex="0">
    <div>
        <!-- <div class="blogPageLeftSide" id="knapsackLeftSide"></div> -->
        <div class="content-header--story"></div>


    </div>

    <div class="content-container content-row story-page story-page--restricted story-page--bottom">
        <div class="grid">

                <div class="grid__item desk--three-twelfths push--desk--one-twelfth tablet--four-twelfths">
                        <div class="story-page__head-shot-container">
                            <div class="grid__item desk--four-twelfths story-page__head-shot-image" style="background-color: #fff;">
                            </div>
                            <div class="desk--eight-twelfths story-page__head-shot-caption">
                                    <p class="story-page__head-shot-caption--text story-page__head-shot-name" tabindex="-1">System design</p>
                                    <p class="head-shot-short-desc">Streaming, Kafka, Publish-subscribe, Message queues</p>          
                            </div>
                        </div>
        
                    </div>
            <div class="grid__item desk--eight-twelfths push--desk--one-twelfth tablet--eight-twelfths story-page__story">
                <h1  class="content-title content-title--story">
                    Kafka
                </h1>

        

                                                <p class="paragraphFontStyle"> 
                                                        Kafka is a distributed and fault tolerant data streaming platform primarily
                                                         used for building realtime data pipelines that transmit data among services. 
                                                         It aims to provide a high throughput, low latency platform for handling 
                                                         real-time data feeds. There are a number component involved
                                                         in a Kafka-based data pipeline.
                                                </p>


                                                <p class="paragraphFontStyle"> 
                                                    
                                                        A <strong>partition</strong> is a particular channel through which data is pushed. 
                                                        One or more partitions together form a topic. Applications can subscribe 
                                                        to a topic and then push messages to a particular partition in the topic. 
                                                        Each partition has a unique sequence ID called an ‘offset’ which is 
                                                        analogous to that of an ‘index’ in an array. A topic 
                                                        can have 0 or more 'consumers' subscribed to it.
                                                </p>

                                                <img src="../images/kafka_partitions.png" style=" width: 60%;"/>




                                                <p class="paragraphFontStyle"> 
                                                        <strong>Producers</strong> are the sources of data that subscribe and push content to Kafka topics.

                                                </p>



                                                <p class="paragraphFontStyle"> 
                                                    
                                                        <strong>Consumers</strong> are applications that subscribe to topics to consume messages, and <strong>consumer groups</strong> 
                                                        are logical groupings of consumers which are used to aggregate consumers. Consumers 
                                                        and Consumer groups dictate how messages are consumed in Kafka. Each consumer 
                                                        in a consumer group consumes a message in a way that’s analogous to that of a messaging 
                                                        queue. So the first consumer in the consumer group to get to a message will consume it. By default, it is Kafka's
                                                        responsibility to partition a topic among the available consumers so that load is evenly 
                                                        balanced. So, if a consumer labelled ‘A’ that belongs to consumer group ‘CG Z’ consumes a 
                                                        message ‘M’ from a topic, then other consumers in consumer 
                                                        group ‘CG Z’ can’t consume the message ‘M’ unless there is a different instance of it in the topic.
                                                </p>



                                                <p class="paragraphFontStyle"> 
                                                        On the other hand, the way multiple consumer groups subscribed to a topic consume messages is analogus to that of a 
                                                        publish-subscribe messaging system. This means a message published to a topic is 
                                                        available to all consumer groups subscribed to the topic. So in a way, Kafka combines 
                                                        two forms of messaging systems: Publish-subscribe for consumer groups & messaging queues for consumers in a consumer group.
                                                </p>

                                                <p class="paragraphFontStyle"> 
                                                   
                                                        <strong>Brokers</strong> are just the Kafka servers or nodes. As a distributed commit log,
                                                         Kafka stores, receives and sends messages on different brokers.
                                                </p>

                                                <img src="../images/kafka_producer_consumer.png" style=" width: 60%;"/>


                                                <p class="paragraphFontStyle"> 

                                                        Kafka as a data structure only supports appends. So every new message is appended to the 
                                                        collection of records in a partition. This property ensures ordering and provides a deterministic
                                                         processing. This has huge performance implications. Because of this ordering, reads and writes from 
                                                         disk(which Kafka uses to persist data) are constant time operations which means no need to perform seek 
                                                         operation on disks. 
                                                </p>


                                                <p class="paragraphFontStyle"> 
                                                        Reads and writes don’t affect each other so, writing would not lock reading. What this means is that 
                                                        data size id decoupled from performance. So weather you have a 100kb or 100TB of data in your server, 
                                                        performance is more or less the same.
                                                </p>

                                                <p class="paragraphFontStyle"> 
                                                        Kafka itself is not concerned with the content of the messages themselves. Data of many different types
                                                         can easily coexist on the same cluster, divided into topics for each type of data. Producers and 
                                                         consumers only need to concern themselves with the topics they are interested in.
                                                </p>

                

                                                <p class="paragraphFontStyle">  
                                                        Kafka also doesn’t keep track of what records are read by the consumer. The consumer group offset
                                                         moves ahead by one as the consumer reads messages. It's not the broker's responsibility to keep track of that. 
                                                         So to remove a message, there is usually set amount of time.
                                                </p>
                                               
                                                <p class="paragraphFontStyle">  
                                                        
                                                        When it comes to data replication, messages are replicated across multiple brokers to preserve data 
                                                        in case of broker failure. At all times, there is a primary broker known as the ‘partition leader’, and this broker is responsible 
                                                        for application writes and reads from/to partitions. It also replicates data to other brokers. This is why 
                                                        successfully pushed data is guaranteed to be available. You can tune performance and durability by changing the 
                                                        replication factor depending on the nature of the data. In some cases, performance might be more important than 
                                                        strong durability guarantees so the replication factor could be lower.

                                                 </p>

                                                    <p class="paragraphFontStyle">  
                                                            Metadata information about the leader is stored in a distributed key-value store known as zookeeper. This server 
                                                            is extremely fault tolerant. It stores information such as consumer group offset per partition and partition 
                                                            leader information. Producers and consumers get this metadata from the primary broker they’re connected to. 
                                                            The broker will then have to contact zookeeper to get this information.

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            
                                                            So, to recap the flow of data through Kafka, producers append messages or records to a partition in a topic. 
                                                            Every consumer group subscribed to the topic will have access to that message. However, only one consumer per 
                                                            consumer group will get the message. For example, let’s assume there is an application ‘A’ that pushes change 
                                                            notifications to a topic. There are twelve instances of Application ‘B’ that are ready to consume and process 
                                                            these change notifications. Since each instance is in the same consumer group which represents application ‘B’, 
                                                            only one instance out of the twelve needs to pick up the notification and process the changes. However if there 
                                                            is a third application, application ‘C’, that wants to consume change notifications, then it would subscribe to 
                                                            the topic with a different consumer group. This way, we can ensure a single change notification makes it to both 
                                                            applications and is only consumed once by each application.

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            If data is the lifeblood of any system, Kafka is the circulatory system. So just like healthy blood vessels and a healthy 
                                                            heart are required for optimal blood flow, it’s important to tune and configure consumers and producers 
                                                            properly to ensure there is proper data flow. So for Kafka to excel, the entire data pipeline(producers, Kafka, consumers) 
                                                            need to coordinate and work seamlessly. Otherwise, we’ll end up with situations where consumers can’t keep up with 
                                                            incoming messages. Consumer lag measures how far behind a consumer is from the most recent offset. Significant consumer 
                                                            lags may even result in data loss of the oldest records in the topic. Some records’s time in the topic might exceed the 
                                                            retention period so those records might be deleted prior to consumption. So, it’s ideal to have all components working 
                                                            together so they respond automatically to events such as increased data flow rate, failure of producers and consumers 
                                                            and so forth.

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            It is important to remember that all consumers in a consumer group work in a load balanced mode. So, if a topic has 6 partitions
                                                             and 6 consumers per group, each consumer in that group should be assigned a partition. If a consumer goes down, Kafka 
                                                             will perform partition rebalancing to reassign consumers to a partition. Since there are more partitions than consumers, 
                                                             there maybe a consumer that consumes from more than one partition. 

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            Frequent partition rebalancing could potentially disrupt the proper flow of data through the pipeline. Every time there is 
                                                            a change in the consumer group, Kafka will rebalance partitions. So, to properly scale consumers up or down with minimal 
                                                            disruption, the consumer can use the Kafka API to assign static partitions and also perform manual load balancing. 
                                                            This is particularly helpful if you set the consumer to autoscale based on the consumer record lag. In most cluster 
                                                            management services such as ECS or Kubernetes, it is possible to use custom metrics set up and exposed by the deployed 
                                                            application. By default, there are some metrics available in these services that trigger autoscaling such as CPU utilization 
                                                            and memory usage. However, it is possible to integrate consumer record lag and use that metric to autoscale the consumer applications. 

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            Scaling consumers is limited by the number of partitions in the topic that the consumers are subscribed to. Since by 
                                                            default, load is evenly balanced among consumers, scaling up consumers beyond the number of available partitions 
                                                            in the topic wouldn’t do any good. So it’s important to think about the appropriate number of partitions while 
                                                            setting up the Kafka infrastructure.

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            When pushing records to topics, it is also important to use a random partitioning scheme to make sure 
                                                            data is distributed as uniformly as possible. Otherwise, some consumers will end up consuming more 
                                                            messages than others since data is not evenly distributed across partitions. 

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            So it’s important to take into consideration the nature of data flowing through the pipeline, and also analyze resources 
                                                            producers and consumers are using when configuring Kafka components. For example, if you have a consumer that consumes 
                                                            messages from a Kafka topic and subsequently updates a DB shard, it might be useful to play around and tune consumer 
                                                            properties such as ‘maxPolledRecords’ which represents the maximum number of records pulled from the topic and 
                                                            ‘poolSize’ which determines the number of records to process concurrently from the polled records. You can fine 
                                                            tune these two settings in this particular case to have multiple consumer threads concurrently consume messages 
                                                            and update shards independently. It might also help to compare and contrast the performance when playing around 
                                                            with the number of consumer threads and the number of shards.

                                                    </p>

                                                    <p class="paragraphFontStyle">  
                                                            Another important use case to consider when tuning consumers is is back pressure. It may be wise in some situations to 
                                                            have consumers consume into a fixed size buffers to prevent too much data from being polled by the consumer on to the 
                                                            heap and prevent unnecessary amount of time spent on garbage collection. Prolonged garbage collection pauses is another 
                                                            thing that can cause consumer group rebalance.
                                                    </p>

                                     
                                
                                                


                                          
            </div>
        </div>
    </div>

    <div class="page-row-2">
        <div class="content-container">
            <div class="grid">
                <div class="grid__item desk--eight-twelfths push--desk--four-twelfths tablet--eight-twelfths push--tablet--four-twelfths">
                    <h2 class="related-content__header">Related content</h2>
                       




                    



                        <!-- test 3-->
                        <div class="content-container mobile--hide" style="padding-left: 0;">
                                <div class="content-row content-row--flush-bottom related-content related-content--padded">
                                    <div class="grid">
                                            <div class="grid__item tablet--one-half related-content__item--shifted desk--one-third">
                                                <div class="related-content__item">
                                                    <h4 class="related-content__title">
                                                        <a  class="relatedContentLink" href="https://kafka.apache.org/23/documentation/streams/architecture">Architecture of Apache Kafka</a>
                                                    </h4>
                                                    <p class="related-content__content">Y
                                                        Higher level architecture of the kafka infrastructureg
                                                    </p>
                                                </div>
                                            </div>
    
                                            <!--item 2-->
                                            <div class="grid__item tablet--one-half related-content__item--shifted desk--one-third">
                                                    <div class="related-content__item">
                                                        <h4 class="related-content__title">
                                                            <a  class="relatedContentLink" href="https://medium.com/@durgaswaroop/a-practical-introduction-to-kafka-storage-internals-d5b544f6925f">Kafka's storage internals</a>
                                                        </h4>
                                                        <p class="related-content__content">Y
                                                            Deeper dive into how partitions and topics are implemented
                                                        </p>
                                                    </div>
                                                </div>

                                                             <!--item 2-->
                                            <div class="grid__item tablet--one-half related-content__item--shifted desk--one-third">
                                                    <div class="related-content__item">
                                                        <h4 class="related-content__title">
                                                            <a  class="relatedContentLink" href="https://www.confluent.io/blog/how-choose-number-topics-partitions-kafka-cluster/">Partitioning topics</a>
                                                        </h4>
                                                        <p class="related-content__content">Y
                                                                An article about how to choose the number of topics/partitions in a Kafka cluster
                                                        </p>
                                                    </div>
                                                </div>
    
                                    </div>
                                </div>
                            </div>

                </div>
            </div>

        </div>

    </div>
</div>


<footer class="hashcode-footer mdl-mini-footer">
	    <div class="mdl-mini-footer__left-section">
		   <p class="mdl-typography--font-light">

              © 2020 Study space

			  <a href="../index.html">
			      Go to homepage
			  </a>

			  <a href="../notes.html">
			      Read notes
			  </a>

			  <a href="../resources.html">
			      Browse through resources
			  </a>

			  <a href="https://www.linkedin.com/in/nathnael-alemu-1b78bb107/">
			      View LinkedIn
			  </a>

		   </p>
		</div>

	</footer>


</body>


</html>